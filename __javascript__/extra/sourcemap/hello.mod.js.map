{
	"version": 3,
	"file": "/home/markus/Desktop/my_parser/__javascript__/hello.mod.js",
	"sources": [
		"/home/markus/Desktop/my_parser/hello.py"
	],
	"sourcesContent": [
		"# https://transcrypt.org/docs/html/index.html\n# https://transcrypt.org/examples#plotly_demo\n# https://transcrypt.org/numscrypt/docs/html/supported_constructs.html\n# for cmath: https://transcrypt.org/docs/html/supported_constructs.html#module-cmath-allmost-all-of-python-s-cmath-module\n# installation path: ~/anaconda3/lib/python3.6/site-packages/transcrypt$\n#                    ~/anaconda3/lib/python3.6/site-packages/transcrypt/modules/org/transcrypt$\n\n# overloading params: https://www.python-course.eu/python3_magic_methods.php (NICE Tutorial!)\n\n\n# Imports:\nfrom org.transcrypt.stubs.browser import *\nfrom org.transcrypt.stubs.browser import __main__, __envir__, __pragma__\nfrom itertools import chain\nfrom math import *\n\n# Imports for Transcrypt, skipped runtime by CPython\nif __envir__.executor_name == __envir__.transpiler_name:\n\timport numscrypt as num\n\n# Imports for CPython, skipped compile time by Transcrypt\n__pragma__ ('skip')\nimport numpy as num  # -> list of functions: https://transcrypt.org/numscrypt/docs/html/supported_constructs.html\n__pragma__ ('noskip')\n\n\nclass Symbolic:\n    def __init__(self, numeric_value, symblic_value=''):\n        self.numeric_value = numeric_value\n        self.symblic_value = self.convert_to_no_s(symblic_value)\n\n    def convert_to_no_s(self, input_value):\n        # input_value ex.: '10s'\n        input_value = input_value.replace(\" \", \"\")\n        if input_value == \"s\":\n            input_value = \"1\"\n        else:\n            input_value = input_value.replace(\"s\", \"\")\n        return input_value\n\n    def __add__(self, other):\n        tmp1 = float(self.numeric_value) + float(other.numeric_value)\n        tmp2 = float(self.symblic_value) + float(other.symblic_value)\n        return str(tmp1) + \"+\" + str(tmp2) + \"s\"\n\n    def __mul__(self, other):\n        tmp1 = float(self.numeric_value) * float(other.numeric_value)\n        tmp2 = float(self.symblic_value) * float(other.symblic_value)\n        return str(tmp1) + \"*\" + str(tmp2) + \"s\"\n\n    def __str__(self):\n        return str(self.numeric_value) + \"+\" + self.symblic_value + \"s\"\n\n\nclass SimactBasic():\n    #global variables\n    function_list = ['plot','linspace','add','dot','func','syms']\n    local_storage = {}\n\n    def __init__(self):\n        pass\n\n    def __add__(self, other):\n        print(\"now in mul\")\n\n    def convert_format(self, input_str):\n        # interpret as nd Matrix array!\n        print(input_str)\n        if \"[\" in input_str:\n            input_str = input_str.split(\"],[\")\n            for i in range(len(input_str)):\n                input_str[i] = input_str[i].replace(\"[\", \"\")\n                input_str[i] = input_str[i].replace(\"]\", \"\")\n                input_str[i] = input_str[i].split(\",\")\n            return (num.array(input_str, dtype=float))\n        if input_str.isdigit():\n            return float(input_str)\n        if \"'\" in input_str:\n            input_str = input_str.replace(\"'\", \"\")\n        return str(input_str)\n\n    def fixed_length_string(self, input_str, max_length):\n        length = len(input_str)\n        if (length > max_length):\n            return input_str[:max_length - 3] + \"...\"\n        else:\n            tmp = max_length - length\n            tt = \"\"\n            for i in range(tmp):\n                tt = tt + \" \"\n            return input_str + tt\n\n    def print_local_storage(self):\n        output_text = self.fixed_length_string(\"Variable\", 12) + self.fixed_length_string(\"Content\",\n                                                                                          18) + \"\\t\" + \"Dim\"\n        for key, value in self.local_storage.items(self):\n            dim = \"1\"\n            try:\n                dim=((num.array(value).shape))\n            except:\n                print(\"Could not get shape of \"+key)\n            out_str = str(value)\n            out_str = out_str.replace(\"\\n\", \" \")\n            out_str = out_str.replace(\" \", \"\")\n            out_str = out_str.replace(\"\\t\", \"\")\n            out_str = out_str.replace(\"][\", \"],[\")\n            output_text = output_text + \"\\n\" + self.fixed_length_string(str(key), 12) + self.fixed_length_string(\n                out_str, 18) + \"\\t\" + dim\n        document.getElementById('local_storage').value = (output_text)\n\n    def dot(self, arg1, arg2):  # working try it with: A=dot([[1,2],[3,4]],[[1,1],[0,1]])\n        __pragma__('opov')\n        return arg1 @ arg2\n        __pragma__('noopov')\n\n    def linspace(self, start, end, disk):  # x=linspace(1,2,0.1)\n        # start, end, disk float or real numbers!\n        tmp = []\n        for i in range(start, (end - start) / disk + 2):\n            tmp[i - 1] = str(start + (i - 1) * disk)\n        return (num.array(tmp, dtype=float))\n\n    def func(self, formula, x_vec):  # x=linspace(0,10,0.1) -> y=func(2*x+sin(x),x)\n        x_vec = x_vec.tolist()\n        result = []\n        for i in range(len(x_vec)):\n            tmp = formula.replace('x', str(x_vec[i]))\n            result[i] = eval(tmp)\n        return num.array(result, dtype=float)\n\n    def plot(self, y_values_in, x_values_in=self.linspace(-5, 5, 0.1), title=\"Output_Plot\", xname=\"x\", yname=\"y\"):\n        # x values, y_values should come in as ndarray -> convert them to list as plotly works with lists!\n        __pragma__('jskeys')  # For convenience, allow JS style unquoted string literals as dictionary keys\n        if \"stringable\" in str(type(y_values_in)):  # in case of a function: like: y=plot('sqrt(x)')\n            title = \"y=\" + str(y_values_in)\n            y_values_in = self.func(y_values_in, x_values_in)\n        x_values = x_values_in.tolist()\n        y_values = y_values_in.tolist()\n        kind = 'linear'\n        Plotly.newPlot(\n            kind,\n            [\n                {\n                    x: x_values,\n                    y: y_values,\n                }\n                # for yValues in y_values_list\n            ],\n            {\n                title: title,\n                xaxis: {title: xname},\n                yaxis: {title: yname}\n            }\n        )\n        __pragma__('nojskeys')\n        return num.vstack((x_values_in, y_values_in))\n\n    def add(self, arg1, arg2):\n        return (arg1 + arg2)\n\n    def syms(self, arg1, arg2):\n        a = Symbolic(arg1, arg2)\n        print(a)\n        return  a\n\n    def parse_input(self):\n        input_str = document.getElementById('input').value\n        # print(input_str)\n\n        # ist es eine Zuweisung? e.g: A=rank(B), A=[[1,0],[0,1]]\n        if \"=\" in input_str:\n            input_str = input_str.replace(\" \", \"\")\n            index_gleich = input_str.find('=')\n            left_string = input_str[:index_gleich]\n            right_string = input_str[(index_gleich + 1):]\n            if \"(\" in right_string:\n                function_name = right_string[:right_string.find(\"(\")]\n                tmp = right_string[right_string.find(\"(\") + 1:len(right_string) - 1]\n                tmp = tmp.replace(\" \", \"\")\n                if \"]],\" in tmp:\n                    arguments = tmp.split(\"]],\")\n                    arguments[0] = arguments[0] + \"]]\"\n                else:\n                    arguments = tmp.split(',')\n\n                for i in range(len(arguments)):\n                    print(arguments[i])\n                    # replace arguments with local storage!\n                    if arguments[i] in self.local_storage:\n                        print(\"argument found in local storage!\")\n                        arguments[i] = self.local_storage.get(arguments[i])\n                        print(arguments[i])\n                    else:\n                        arguments[i] = self.convert_format(arguments[i])\n                    print(arguments[i])\n\n            if function_name in self.function_list:\n                # execute the function:\n                if len(arguments) == 1:\n                    result = getattr(simactBasic, function_name)(arguments[0])\n                if len(arguments) == 2:\n                    result = getattr(simactBasic, function_name)(arguments[0], arguments[1])\n                if len(arguments) == 3:\n                    result = getattr(simactBasic, function_name)(arguments[0], arguments[1], arguments[2])\n                if len(arguments) == 4:\n                    result = getattr(simactBasic, function_name)(arguments[0], arguments[1], arguments[2],\n                                                                 arguments[3])\n                if len(arguments) == 5:\n                    result = getattr(simactBasic, function_name)(arguments[0], arguments[1], arguments[2],\n                                                                 arguments[3], arguments[4])\n            else:\n                print(\"ERROR function \" + function_name + \" unknown! See help functions\")\n\n        else: # execute command like A+B\n            scope = {}\n            a = Symbolic('2', '4s')\n            scope[\"a\"]=a\n            __pragma__('opov')\n            print(eval(\"a+a\",scope))\n            __pragma__('noopov')\n\n\n            # gut geht in normal python aber hier nicht :(\n            #scope = {}\n            #b=Symbolic('2', '4s')\n            #scope[\"a\"]=b\n            #inputstr = \"a+a\"\n            #print(eval(inputstr, scope))\n\n            #print(input_str)\n            #a = self.local_storage.get(\"a\")\n            #print(type(a).__name__)\n            #print(a.numeric_value)\n            #print(a.symblic_value)\n            #print(eval(input_str))\n            #__pragma__('opov')\n            #c=a+a\n            #print(eval(input_str))\n            #__pragma__('noopov')\n            #print(c)  # gibt mir 2+2s !!!\n            #print(type(c).__name__) #str\n\n            #a = Symbolic('2', '4s')\n            #b = Symbolic('5', '8s')\n            #__pragma__('opov')\n            #c = 'a+a'\n            #__pragma__('noopov')\n            #print(c)\n            #print(eval('c'))\n            #input_str=input_str.replace(\"A\",\"Symbolic('5', '8s')\")\n            #input_str=input_str.replace(\"B\",\"Symbolic('5', '8s')\")\n            #print(input_str)\n            #print(eval(\"input_str\"))\n\n        self.local_storage[left_string] = result\n        print(self.local_storage)\n\n        # write in output window:\n        self.print_local_storage()\n\nsimactBasic = SimactBasic()\n"
	],
	"mappings": "AAAA;AAAA;AAaA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AACA;AAAA;AAQA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAEA;AAEA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AAEA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AAAA;AAEA;AACA;AAAA;AAAA;AAGA;AAAA;AAEA;AACA;AAEA;AACA;AAAA;AAEA;AACA;AAAA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AAEA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AAAA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AAAA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAgBA;AAAA;AAEA;AACA;AAAA;AAEA;AACA;AACA;AACA;AAAA;AAEA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AAEA;AAEA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAEA;AACA;AAAA;AAAA;AAEA;AACA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AAEA;AA4BA;AAQA;AACA;AAGA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA"
}