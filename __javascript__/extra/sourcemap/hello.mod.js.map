{
	"version": 3,
	"file": "/home/markus/Desktop/my_parser/__javascript__/hello.mod.js",
	"sources": [
		"/home/markus/Desktop/my_parser/hello.py"
	],
	"sourcesContent": [
		"# Imports:\nfrom org.transcrypt.stubs.browser import *\nfrom org.transcrypt.stubs.browser import __main__, __envir__, __pragma__\nfrom itertools import chain\nimport math\n\n# Imports for Transcrypt, skipped runtime by CPython\nif __envir__.executor_name == __envir__.transpiler_name:\n\timport numscrypt as num\n\n# Imports for CPython, skipped compile time by Transcrypt\n__pragma__ ('skip')\nimport numpy as num  # -> list of functions: https://transcrypt.org/numscrypt/docs/html/supported_constructs.html\n__pragma__ ('noskip')\n\n\nclass SimactBasic():\n    #global variables\n    function_list = ['plot','linspace','add','dot']\n    local_storage = {}\n\n    def __init__(self):\n        pass\n\n    def convert_format(self, input_str):\n        # interpret as nd Matrix array!\n        print(input_str)\n        if \"[\" in input_str:\n            input_str = input_str.split(\"],[\")\n            for i in range(len(input_str)):\n                input_str[i] = input_str[i].replace(\"[\", \"\")\n                input_str[i] = input_str[i].replace(\"]\", \"\")\n                input_str[i] = input_str[i].split(\",\")\n            return(num.array(input_str,dtype=float))\n        if input_str.isdigit():\n            return float(input_str)\n        return input_str\n\n    def fixed_length_string(self,input_str,max_length):\n        length = len(input_str)\n        if(length>max_length):\n            return input_str[:max_length-3]+\"...\"\n        else:\n            tmp = max_length-length\n            tt=\"\"\n            for i in range(tmp):\n                tt=tt+\" \"\n            return input_str+tt\n\n    def print_local_storage(self):\n        output_text =self.fixed_length_string(\"Variable\",12)+self.fixed_length_string(\"Content\",18)+\"\\t\"+\"Dim\"\n        for key, value in self.local_storage.items(self):\n            dim=((num.array(value).shape))\n            out_str = str(value)\n            out_str =out_str.replace(\"\\n\",\" \")\n            out_str = out_str.replace(\" \",\"\")\n            out_str = out_str.replace(\"\\t\", \"\")\n            out_str = out_str.replace(\"][\", \"],[\")\n            output_text=output_text+\"\\n\"+self.fixed_length_string(str(key),12)+self.fixed_length_string(out_str,18)+\"\\t\"+ dim\n        document.getElementById('local_storage').value=(output_text)\n\n    def dot(self, arg1, arg2): #working try it with: A=dot([[1,2],[3,4]],[[1,1],[0,1]])\n        __pragma__('opov')\n        return arg1@arg2\n        __pragma__('noopov')\n\n    def linspace(self, start, end, disk): #x=linspace(1,2,0.1)\n        # start, end, disk float or real numbers!\n        tmp = []\n        for i in range(start,(end-start)/disk+2):\n            tmp[i-1]=str(start+(i-1)*disk)\n        return (num.array(tmp, dtype=float))\n\n    def plot(self, x_values_in, y_values_in, title=\"Output_Plot\", xname=\"x\", yname=\"y\"):\n        # x values, y_values should come in as ndarray -> convert them to list as plotly works with lists!\n        __pragma__('jskeys')  # For convenience, allow JS style unquoted string literals as dictionary keys\n        x_values = x_values_in.tolist()\n        y_values = y_values_in.tolist()\n        kind = 'linear'\n        Plotly.newPlot(\n            kind,\n                [\n            {\n                x: x_values,\n                y: y_values\n            }\n            #for yValues in y_values_list\n                ],\n                    {\n                    title: title,\n                    xaxis: {title: xname},\n                    yaxis: {title: yname}\n                    }\n        )\n        __pragma__('nojskeys')\n        return num.vstack((x_values_in, y_values_in))\n\n    def add(self, arg1, arg2):\n        return(arg1+arg2)\n\n    def parse_input(self):\n        input_str = document.getElementById('input').value\n        #print(input_str)\n\n        # ist es eine Zuweisung? e.g: A=rank(B), A=[[1,0],[0,1]]\n        if \"=\" in input_str:\n            input_str = input_str.replace(\" \",\"\")\n            index_gleich = input_str.find('=')\n            left_string = input_str[:index_gleich]\n            right_string = input_str[(index_gleich+1):]\n            if \"(\" in right_string:\n                function_name = right_string[:right_string.find(\"(\")]\n                tmp = right_string[right_string.find(\"(\")+1:len(right_string)-1]\n                tmp = tmp.replace(\" \",\"\")\n                if \"]],\" in tmp:\n                    arguments=tmp.split(\"]],\")\n                    arguments[0]=arguments[0]+\"]]\"\n                else:\n                    arguments = tmp.split(',')\n\n                for i in range(len(arguments)):\n                    print(arguments[i])\n                    # replace arguments with local storage!\n                    if arguments[i] in self.local_storage:\n                        print(\"argument found in local storage!\")\n                        arguments[i]=self.local_storage.get(arguments[i])\n                        print(arguments[i])\n                    else:\n                        arguments[i]=self.convert_format(arguments[i])\n                    print(arguments[i])\n\n            if function_name in self.function_list:\n                #execute the function:\n                if len(arguments) == 1:\n                    result = getattr(simactBasic, function_name)(arguments[0])\n                if len(arguments) == 2:\n                    result = getattr(simactBasic, function_name)(arguments[0], arguments[1])\n                if len(arguments) == 3:\n                    result = getattr(simactBasic, function_name)(arguments[0], arguments[1], arguments[2])\n                if len(arguments) == 4:\n                    result = getattr(simactBasic, function_name)(arguments[0], arguments[1], arguments[2], arguments[3])\n                if len(arguments) == 5:\n                    result = getattr(simactBasic, function_name)(arguments[0], arguments[1], arguments[2],arguments[3], arguments[4])\n            else:\n                print(\"ERROR function \"+function_name+\" unknown! See help functions\")\n\n            print(\"result: \")\n            print(result)\n\n\n        self.local_storage[left_string]=result\n        print(self.local_storage)\n\n        self.print_local_storage()\n\n        #data.clear()  # Clears entire dictionary\nsimactBasic = SimactBasic()\n"
	],
	"mappings": "AAAA;AA4JA;AA5JA;AAGA;AACA;AAGA;AACA;AAAA;AAQA;AAAA;AAEA;AACA;AAEA;AACA;AAAA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AAAA;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AACA;AACA;AACA;AAgBA;AAAA;AAEA;AACA;AAAA;AAEA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AAEA;AAEA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAEA;AACA;AAAA;AAGA;AACA;AAEA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA"
}